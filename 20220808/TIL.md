# 20220808 TIL

## 알고리즘 개념

알고리즘은 어떠한 문제를 푸는 절차 혹은 방법이다.
이를 표현하는데에는 의사코드(슈도코드), 순서도가 있다. 의미는 같으나 문장인지 순서를 도형으로 나타내는지에 차이가 있다.
알고리즘을 판별하는데에는 총 5가지가 존재한다.
1. 정확성 : 얼마나 정확하게
2. 작업량 : 얼마나 적은 연산을
3. 메모리 사용량 : 얼마나 적은 메모리를
4. 단순성 : 얼마나 단순하게
5. 최적성 : 더이상 개선여지가 없는지
  
이러한 점을 보아 더 좋은 알고리즘인지 판단해야한다.
대체로 알고리즘을 분석할때 수치적으로 나오는것은 시간복잡도로 실제 걸리는 시간에 대한 측정이다.
단순히 길다고 복잡하다고 보지는 않고, 반복되는것이 많음에 따라 복잡도가 커진다.
보통 빅오 표기법으로 O(3n+2) 처럼 표기된다.

## 버블정렬
인접한것 2개씩을 비교하면서 정렬하는 모습이 거품이 이는거같아 버블정렬이라 부른다.
일반적으로 처음부터 시작해서 인접한 2개씩 비교해서 마지막까지 이동한다.
그 이후 정렬이 완료된 마지막칸을 제외하고 다시 처음부터 비교를 시작한다.
따라서 버블정렬은 for문 2개가 중첩되며 한개(i)는 n-1,1,-1 로 한개(j)는 1에서 i까지 반복한다.

![버블정렬](/image/20220808_1.jpg)

(예시)
```python
# 내림차순정렬일때
N = 5
for i in range(N-1,1,-1):  # 실행하는 횟수, 검색해야하는 마지막위치
    for j in range(1,i):  # 첫칸부터 마지막위치까지 움직여야하는 idx
        if list[j] < list[j+1]:
            list[j] , list[j+1] = list[j+1] , list[j]
```

결과값은 우리가 아는 sort.

## 카운팅 정렬
주어진 값의 최대값 혹은 범위를 알아야하고 그 모든값이 정수형이야지 사용 가능하다.  
시작~끝까지 값자체를 idx로 사용해서 cnt 리스트에 +=1을 한다.
끝이나면 값이 들어간 갯수를 알수있는 cnt 리스트가된다.

이후에 cnt 리스트에 앞에값을 바로뒤에 더하는식을 반복하여 누적값 cnt리스트를 만든다.
그 이후에 원형 list를 반대로 탐색하면서 누적값cnt를 보면서 정렬이된 리스트를 작성한다.

![카운팅정렬1](/image/20220808_2.jpg)
![카운팅정렬2](/image/20220808_3.jpg)
![카운팅정렬3](/image/20220808_4.jpg)


(예시)
```python
# 오름차순정렬일때
N = 5
for i in range(N):  # 실행하는 횟수, 검색해야하는 마지막위치
    cnt[list[i]] +=1

for j in range(1,10):
    cnt[j] = cnt[j] + cnt[j-1]

for l in range(N-1,-1,-1):
    cnt[list[l]] -= 1
    new[cnt[list[l]]] = list[l]
```
