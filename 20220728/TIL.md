절차지향은 위에서 내려온다, 라기보단 호출 순서에 따라 진행하는 코드.
기존의 절차지향은 모든 코딩을 그때그때 작성하다가, 이후
공통된 코드를 함수를 통해 작성하는것으로 발전하였다.
가장 큰 단점은 프로그램이 커짐으로 인해, 필요한 변수의 양이
급속도로 증가한다는 점이였다. 

이를 해결하기 위한것이 객체지향으로, 비슷한것의 변수, 함수를
하나의 박스로 즉 클래스로 묶어준것이다. 이를 통해 엄청난
효율적인 코딩과, 확장성을 고려한 코딩이 가능해진것이다.

객체는 역할 책임 협력의 특성을 가진다?
역할(클래스) - 클래스 
책임(메서드) - 함수,실행결과 
협력(호출,결과) -  요청을하고 응답을함
각 객체에에게는 '역할'이 있다. 역할이 있는 객체는 그 각각에
'책임'이 존재한다. 각 객체는 서로서로 '협력'한다.

추상화는 불필요한것을 거르고 사용에 필요한것만 나타낸다.
휴대폰 기능을 알지못해도 쓰는것처럼.
우리는 코딩을 할때 print함수가 어떻게 작동하는지 정확하게 이해하지않는다
def, 변수지정에 따른 주소할당, random의 난수 뽑는 방식등.
심지어 마우스가 움직이는 원리나 키보드의 입력조차도 이해하지않는다.
그렇지만 실제로 마우스를 움직일수있고, print함수를 쓸수있다.

이런것은 함수와함수, 객체와 객체간에도 마찬가지이다. 서로를 이해하지않아도
작성된 코드를 통해 서로 호출하고 응답을 받을 수 있는것이다.

추상화,캡슐화,다형성,상속 객체의 특징이 있지만
이는 모두 추상화로 묶을 수 있다.
추상화는 서로가 서로에 대해 확실하게 알 필요가 없다. 라는 문맥으로 이해할 수 있다
그렇다면 이를 통해 캡슐화를 본다면, 서로 확실하게 알 필요가 없는것처럼
그 서로에게 참여하지도 말아야한다는것으로 이어진다.
따라서 보통 요청하고 결과만 받지, 실질적인 클래스에 대한 데이터를 직접 참조하거나
삭제하려 하지않는다.
또한 다형성을 본다면, 요청에 대한 결과만 잘 받으면 되기때문에, 그것이 어떻게 변화하던 상관이 없다는것이다.
이를통해 꼭 그 1개가 아닌, 무엇이든 상관이 없게된다.
또한 상속을 본다면, 

난 이 설명이 더 어렵네..

인스턴스는 oo의 객체라고 단정지을 수 있는것.
객체는 객체 그자체.

클래스로 만들어진것은 하나로 추상된것들이다. 즉 이들은 타입이다.

__del__은 변수의 삭제라기보단, 해당 객체의 삭제를 인식하기때문에
간혹 del 을 해도 작동이 하지 않을수있다(2개이상이 참조를할때)


-3 -1 
1 3

-3
-1