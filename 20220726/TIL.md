# 20220726 TIL

# 0725 학습 수강

## 메서드

데이터구조.메서드() 형태로 활용한다.  
문장식으로 읽으면 주어(혹은 명사).동사() 형태라고 생각하면됨.  
따라서 데이터 구조에 맞는 메서드를 사용해서 올바른 값을 출력해내자.  

파이썬에서는 문법표시를 볼수있는데  
일반적으로 들어가있는건 필수, []안에 들어있는건 선택적 인자라고 생각하면된다  
예시 - `str.replace(old,new[,count]) ` 이면 old와 new는 필수, [,count]는 선택인자이다.  
필수는 없으면 오류가 발생되고 선택적 인자는 없어도 상관없이 실행된다.  
보통은 디폴드값이 존재한다.

## 순서가 있는 자료

### 1. 문자열
문자들의 나열로, 모든 문자는 str타입이며 변경이 불가능한 immutable이다. (c처럼 char형이 모여서 str 배열이 되는 형식이 아님.)  
변경이 불가능하다는것은  

```python
a = 'ssafy'
a[3] = 'g'
print(a)    #오류출력 : 'str' object does not support item assignment
```
이러한 방식으로 원하는대로 변경이 불가능하다는것에서 알수있다.  
다만 이런 형태는 변경되는것처럼 보이는데  

```python
a = 'ssafy'
a = 'good'
print(a)    #출력값 good
```

이것은 사실상 변경이 된것이 아니라, 해당 주소가 아닌 새로운 주소에 할당한것이다.  
`id()`로 해당 str의 주소를 확인하면 알 수 있다.   

이러한 문자열에는 여러 메서드가 존재한다  

#### 문자열 조회 및 탐색 , 검색 메서드
(1) s.find(x)  
    x의 첫번재 위치를 반환. 없으면 **-1**를 반환한다.
```python
print('apple'.find('a'))        # 결과 : 0 
print('apple'.find('k'))        # 결과 : -1
```
(2) s.index(x)  
    x의 첫번째 위치를 반환. 없으면 **오류** 발생  
```python
print('apple'.find('a'))        # 결과 : 0 
print('apple'.find('k'))        # 결과 : 오류
```
(3) s.isalpha()  
    알파벳 문자 여부 확인 True, False 로 반환 (단순 알파벳이 아니라, 유니코드상. 한국어도 포함이다)  
    'abc' , 'ㄱㄴㄷ' 모두 True.    
    'a!' , ' ' , '0' 는 모두 False  
(4) s.isupper() , s.islower()  
    각각 대문자, 소문자여부를 판단한다. 굳이 ord chr 쓰지않고 사용가능  
    'Ab'.isupper() 는 False, ab.islower() 는 True  
(5) s.istitle()   
    타이틀 형식 여부 (첫글자가 대문자)  
    'Title'.istitle() 은 True  

#### 문자열 변경 메서드
(1) s.replace(old,new[,count])  
    바꿀 대상의 글자를 새로운 글자로 변환.  
    count를 지정하면 해당 개수만큼 시행. 디폴트는 한번  
(2) s.strip([chars])  
    공백 혹은 특정 문자를 제거  
    lstrip은 왼쪽을, rstrip은 오른쪽을 제거한다.  
    chars 지정을 안하면 공백을 제거한다.  
(3) s.split(sep=None , maxsplit = -1)  
    공백이나 특정 문자 기준으로 분리  
    디폴트는 공백이라는 뜻. maxsplit은 제한없이 실행한다는뜻  
(4) 구분자.join(변수명)  
    해당 변수에 들어있는 데이터를 구분자를 중간에 넣으면서 합침.  
    `'-'.join(['010','1234','5678'])` 는 010-1234-5678  


### 2. 리스트

#### 리스트 메서드
(1) L.append(x)  
    리스트의 **마지막**에 항목 x를 추가  
    주소가 변하지않는다. 추가만 하는거니까.  
(2) L.insert(i,x)  
    리스트 인덱스 i에 x를 **삽입**  
    i가 리스트보다 크면 그냥 맨뒤에 넣는다. 오류가 나오지않음  
(3) L.remove(x)  
    리스트 첫번째 x를 제거. **없으면 에러발생.**  
    따라서 에러 검증 필수  
(4) L.pop()  
    리스트 마지막값을 반환후 **제거**  
    괄호안에 값을 넣으면 해당 인덱스값  
(5) L.extend(m)  
    += 같은기능. 끝에 리스트형식으로 넣어준다.  
    리스트를 넣으면 append처럼 들어가는데, 문자열로 넣으면 쪼개져서 들어간다.  
(6) L.index(x,start,end)  
    리스트 첫번째 x의 인덱스 반환.  
    start와 end로 위치 지정가능.  
(7) L.reverse()  
    리스트를 거꾸로 정렬. **sort처럼 원본만 정렬하고 None값 반환.**  
    == [::-1]  
(8) L.sort()  
    리스트를 정렬.  
    오름차순,내림차순 설정도 가능함.  
    이는 원본 리스트를 정렬하고 None값을 반환하는 **void 함수이다.**  
    sorted() 함수와 비교해서 사용해야한다.  
(9) L.count(x)  
    항목 x가 몇개 존재하는지 개수 반환  
    **x가 완전 일치**해야한다.  
(10) L.clear()  
    값을 비워준다. 빈 리스트가 됨  


### 3. 튜플

순서는 있지만 변경이 불가능한 imnmant? 자료형이다.  
리스트가 []로 구분한다면 튜플은 ()로 구분한다.  
리스트와 메서드가 비슷하지만 그 자체를 변환하는건 사용 불가(예로 sort같은거)  
* 2로 2번 반복이다 += a로 데이터 추가는 가능하지만, 문자열과같이 자료자체가 바뀐다.  


### 4. 연산자

(1) 맴버십 연산자 in  
    특정 요소가 속해있는지 판단.  
    not in은 그 반대값.  
(2) 시퀀스형 연산자  
    [1] 산술연산자 +  
    시퀀스간에 연결,연쇄를 한다.  
    리스트+리스트는 두개를 연결하며, 튜플+튜플도 마찬가지로 가능하다.  
    이는 문자열에서도 가능하다.   
    range 같은건 불가능.  
    [2] 산술연산자 *  
    리스트,튜플 * n 는 해당 개수만큼 반복한다.  
    문자열도 가능하다.  
    range 같은건 불가능.  

### 5. set
set이란 중복되는 요소도 X 순서도 X 인 데이터의 묶음.  
중복X이기때문에 중복되면 하나만 저장된다. 순서가 X이므로 인덱스를 이용해 접근이 불가능하다.  
집합 개념을 이용하는 자료형이다.  
변경 및 추가는 가능(가변형)  
셋도 딕셔너리처럼 기본형은 {} 이지만, {}은 딕셔너리로 먼저 인식한다.  
즉 **`print(type({}))` 은 딕셔너리**이다. 따라서 이를 초기화할땐 반드시 `S={''}`형식으로 넣어주자. 혹은 `S=set()` 형식으로 만들자.  
특정 메서드를 제외하고는 안에 값이 리스트,문자열,숫자 등 가능하다.  

(1) S.copy()  
    set의 얕은 복사본 반환  
(2) S.add(x)  
    x를 추가한다. set이기때문에 순서 상관없이 추가만 된다.  
    다만 set이기때문에 중복이면 추가되지않는다.  
(3) S.pop()  
    셋에서 랜덤하게 항목을 반환하고 이를 제거함. 순서가 없기때문에 다른 pop과 다르다.  
    비어있으면 **에러**  
(4) S.remove(x)  
    항목 x를 삭제. 없으면 **에러**  
(5) S.discard(x)  
    항목 x를 삭제. 없어도 **에러는 없다**  
(6) S.update(t)  
    셋 t에 있는 모든 항목을 추가함. set이기 때문에 없는 항목만 추가된다.  
(7) S.clear()  
    모든항목 삭제  
(8) S.isdisjoint(t)  
    S와 t가 **서로소** 즉 완전히 겹치는것이 없으면 True  
(9) S.issubest(t)  
    **S가 t의 하위셋** 즉 부분집합일 경우에 True.  
    함수를 그대로 읽으면 S는 t의 부분셋이다.  
    S == t 여도 서브세트는 맞기에 True  
(10) S.issuperset(t)  
    **S가 t의 상위셋** 즉 역으로 부분집합일때 True.  
    함수를 그대로 읽으면 S는 t의 슈퍼집합(상위집합)이다.  
    S == t 여도 서브세트는 맞기에 True  
+ 위의 집합 함수는 굳이 t가 세트가 아니여도 된다. 리스트도 가능.  
  다만 문자열과 튜플은 안된다. 정상적으로 작동 X  
++ set는 집합표현 방식에 탁월하다.  
   따라서 교집합(&), 합집합(|), 차집합(-), 완전일치(==) 등으로도 많이 사용한다.  
+++ isdisjoint는 세트뿐만아니라 순회형이라면 모두 사용가능하다. 즉 리스트 딕셔너리 튜플 문자열도 가능.  
    하지만 사용되는 방식이 딕셔너리,문자열은 차이가 있다  

```python
# isdisjoint 리스트,딕셔너리,튜플,문자열 사용시
a = {'사과', '바나나', '수박', 'a'}
b = ['사과']
c = {
    '사과': '1',
}
c_2 = {
    '1': '사과',
}
d = ('사과',)
e = '사과'      # == ['사','과']
f = 'a'
print(a.isdisjoint(b))  # False / '사과' 리스트
print(a.isdisjoint(['사과']))  # False / '사과' 리스트

print(a.isdisjoint(c))  # False / '사과' 키값 딕셔너리
print(a.isdisjoint(c_2))  # True  / '1' 키값 딕셔너리 (키값만 찾는다)

print(a.isdisjoint(d))  # False / '사과' 튜플
print(a.isdisjoint(('사과')))  # True  / '사과' 문자열 (튜플로 인식X)

print(a.isdisjoint(e))  # True  / '사과' 문자열. 그러나 '사' , '과' 를 쪼갠 ['사','과'] 의 형태로 검색한다. 따라서 True
print(a.isdisjoint(f))  # False / 'a' 문자열
```

### 6. 딕셔너리

키-값으로 이루어진 자료형.  
key는 불변형 데이터만 사용 가능하며 , 값은 뭐든 상관없다.  
간단하게 set 리스트는 사용이 안된다.  


(1) d.keys()  
    딕셔너리에서 **모든 키**만 담아서 반환  
(2) d.values()  
    딕셔너리에서 **모든 값**만 담아서 반환  
(3) d.items()  
    딕셔너리에서 **모든 키-값을 쌍**으로 담아서 반환  
    리스트 enument 사용 생각하면 편하다  
(4) d.get(k)  
    키 k의 값을 반환하는데 **없으면 None**  
    **단순히 d[key]를 쓰면 없을때 에러**가 나온다. 따라서 get 메서드를 사용한다.  
(5) d.get(k,v)  
    키 k의 값을 반환하는데 **없으면 v**  
(6) d.pop(key[,default])  
    기본 pop과 같다. 없으면 default값을 반환하는데, **이때 default가 없다면 에러**  
(7) d.update()  
    값을 제공하하는 값으로 덮어쓴다.  
    키값은 찾는용도 값은 바뀌는 용도인데, 만약 없다면 해당 키/값으로 새로 넣는다.  

## 얕은복사와 깊은복사

이전에 한번 알아본 개념.  
a=b, a=[[0]\*8]\*8 등이 이러한 얕은 복사를 발생한다.  
이는 값을 복사하는게 아니라, 참조를 복사하기때문에 생기는 문제.  
이를 해결하기 위해선 a = b[:] 같은 방식으로, 연산한 결과를 넣는 방식을 사용해야한다.  
그러나 이 방식도 1차원에서만 가능하다. 왜냐하면 2차원을 [:]로 복사한다해도  
리스트라는 주소를 가져오는 값이 있기때문이다.  

이를 위한 해결방법 deepcopy 메서드로, copy를 import한다.  
copy.deepcopy 메서드를 사용하여 2차원도 문제없이 깊은 복사된다.  


왜 이러한 문제가 생길까?  
그 이유는 파이썬은 long, int, 이런 자료형으로 나누지 않기때문에.  
그냥 주소만 가지고, 그 주소에 자료를 때려박는 형식이기때문이다.  
그렇기에 자료를 대입하면 그 자료를 가져오는 방식이 아니라, 그 주소를 참조하는 방식을 쓰게된다.  



## 자료형 규칙

튜플은 1개 변수만 쓰면 문자열로 인식한다  
따라서 뒤에 , 를 붙여 튜플형임을 알려주자  

```python
a = ('튜플')
print(type(a))  # 값 type str
a = ('튜플',)
print(type(a))  # 값 type tuple
```

