# 20220727 TIL

## 온라인강의 수업내용

### 1. 객체지향 프로그래밍(OOP)

객체지향의 핵심은  
- 추상화
- 상속
- 다형성
- 캡슐화
- 에러와 예외

```
<객체지향 프로그래밍 정의>   
컴퓨터 프로그래밍 패러다임(방법론) 중 하나이다. 객체지향 프로그래밍은 프로그램을 명령어의 목록으로 보는 시각에서 벗어나  
여러개의 독립된 "객체"의 모임으로 파악하고자 하는것이다. 각 개체는 메세지를 주고받고, 데이터를 처리할 수 있다.
```

여러개의 객체의 모임이 있고, 이 객체간에 상호작용으로 프로그래밍 하는 방법이다.
각 객체는 정보(변수)와 행동(함수)을 가지고 있다.  


#### 절차지향과 객체지향의 차이

![절차지향](/image/20220727_2.bmp)

```
하나로 이어져있기때문에 중간에 수정할것이 있으면, 많은것을 수정해야한다.
```

![객체지향](/image/20220727_3.bmp)

```
각각 객체가 유기적으로 연결되어있어 수정시 필요한것만 수정할수 있다.
```

![객체지향 장단점](/image/20220727_4.jpg)

```
장점 : 협업이 쉽고 유지보수에 유리  
단점 : 설계가 어렵고 실행속도가 느림
```

```
<객체 정의>
컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한것을 토대로 메모리에 할당된것으로 프로그램에서 사용되는 데이터 또는  
식별자에 의해 참조되는 공간을 의미하며, 변수,자료구조,함수 또는 메서드가 될 수 있다.

핵심 : 속성(변수)과 행동(함수)으로 구성된 모든것
```

![객체지향 표현](/image/20220727_5.jpg)

기본 표현 방식은 `클래스.속성` , `클래스.행동`
위 사진이 예시를 쓰면 `이찬혁.직업` -> `가수` `이찬혁.랩하기()` -> `어느새~ 부터~`

![객체와 인스턴스](/image/20220727_6.jpg)

인스턴스는 `특정 타입 혹은 클래스의 인스턴스` 식으로 이해하면 편하다.
클래스를 만든다는것은, 타입을 만든다라고 생각하면된다.
<br>

```
**********************************************************
파이썬은 모든것이 객체인, 객체 지향 기반 언어이다.
파이썬의 모든것에는 속성과 행동이 존재한다.
**********************************************************
```

지금까지 쓰던 메서드 함수는 `list.sort()`같은 형식.
이것도 `객체.행동()`으로 모두 객체이다.
`[1,2,3],[1],[],['hi']` 이 안에 모든 값이 리스트 타입(클래스)의 객체이다.
`'','hi','파이썬'` 이 안에 모든값도 문자열 타입(클래스)의 객체이다.
<br>
인스턴스의 개념을 다시 들고와서
*객체는 특정 타입의 인스턴스이다.*
- 123, 900 등은 int의 인스턴스
- 'hi','hello' 등은 string의 인스턴스
- [232,5],[] 등은 list의 인스턴스
<br>

is 동일, ==은 동등 함을 비교한다.
따라서 is는 참조하는 주소까지 같은 아예같은 값이며
==는 단순히 값만 같은것이다.

![클래스변수와 인스턴스변수](/image/20220727_7.jpg)

클래스 변수란 해당 클래스에 속한 모든것의 속성.
인스턴스는 해당 인스턴스의 속성.

![인스턴스 변수 생성자](/image/20220727_8.jpg)

__init__은 생성자로, `def 함수():`로 만들고 `함수()` 로 사용하듯
생성하고 `클래스.name` 형으로 사용하는것이다.
이 생성자는 인스턴스 변수가 생성될때 실행된다.
init에 self는 무조건. 이 self는 자기자신으로 자동으로 들어간다. 기본문법이니 지켜줘야한다.

??????????????????????????????궁금증??????????????????????????????
self, init 어떤 의미로 사용되는걸까?
![생성자](/image/20220727_12.jpg)
init은 무조건 인스턴스 변수가 사용될때 호출한다.
__ㅇㅇㅇ__ 은 던더(더블언더바)로 이게 있는 메서드는 특수한 동작을 위한것으로, 스페셜메서드 혹은 매직 메서드라고 불린다.
(3시 30분대)
??????????????????????????????????????????????????????????????????

![클래스 변수](/image/20220727_9.jpg)

클래스 변수는 <classname(Circle)>.<name(pi)>
클래스변수는 디폴트값과 같은 느낌. 
클래스 변수는 "한 학교의 규칙"이라고 보면, 인스턴스 변수는 "한 반의 규칙" 으로 생각하면 좋을것같다.
어떠한 반의 규칙이 없다면, 학교 규칙으로 사용하는것처럼.

위의 사진에서 pi는 클래스변수, c1/c2는 인스턴스 변수이다.
따라서 Circle(클래스).pi(클래스변수) 형식으로 클래스 변수를 호출하며
만약 인스턴스 변수가 정의가 되지 않는다면, 이것은 클래스변수로 호출된다(위의 예시)
정의가 되는 순간부터 정상적으로 인스턴스변수로써 호출된다.
전에 전역변수, 지역변수 값 변경하는것처럼 클래스변수, 인스턴스변수중 변경해야할것을 잘 골라서 변경하자.

<br>

### 2. 객체지향 메서드

![객체지향 메서드 생성 사용](/image/20220727_10.jpg)

메서드는 클래스 안에 있는 함수이다.
그렇기에 사용방식은 `인스턴스변수.메서드` 가 된다.

(1) 인스턴스 메서드
　인스턴스[변수]를 처리한다.
　따라서 인스턴스 변수를 사용하거나, 값을 설정한다. 클래스에 정의되는 메서드의 기본.
　호출시 첫번째 인자로 자기자신(slef)가 전달된다. 즉 self가 있다면 인스턴스 메서드이다.
![인스턴스 메서드](/image/20220727_11.jpg)
(2) 클래스 메서드
　클래스[변수]를 처리한다.
(3) 정적 메서드
　그 나머지[변수]를 처리한다.

<br>

### 3. 클래스 메서드

(3시30분대)

![데코레이터(클래스함수) 없이 함수꾸미기](/image/20220727_15.jpg)

![데코레이터(클래스함수)로 함수꾸미기](/image/20220727_16.jpg)


데코레이터가 없다면, 모든 함수에 일일히 넣어줘야한다. 
하지만 @ 데코레이터 함수를 이용하면 좀더 편리하게 꾸밀수 있는것이다.

```
클래스 메서드 vs 인스턴스 메서드
클래스 메서드는 클래스 변수를 사용하며, cls가 들어간다
인스턴스 메서드는 인스턴스 변수를 사용하며, self가 들어간다.

제일 큰 차이는 클래스 메서드에서는 인스턴스 변수 사용이 불가능하기때문에
인스턴스 메서드를 통해 인스턴스, 클래스 변수를 사용한다.
```

<br>

### 4. 스태틱 메서드(동적메서드)

인스턴스, 클래스 변수를 사용하지 않는다.
cls도, self도 없다. @staticmethod로 정의한다. `사용방식은 마치 일반 함수와 같다.`
데이터를 다루지않고, 단지 기능만 하는 메서드.

<br>

### 5. 메서드정리

```
self 인스턴트, cls 메서드, 없으면 static.

obj.instant() 가능
class.instant() 가능 / 그러나 self가 자동으로 들어가지는 않음
class.class() 가능
obj.class() 불가능


```

<br>

### 6. 상속

객체지향의 핵심(이라고하심)
```
상속이란, 두클래스 사이 부모-자식 관계를 정립하는것.
모든 파이썬 클래스는 object를 상속받는다.
따라서 하위 클래스는 상위 클래스에 정의된 속성,행동,관계 등등 모든것을 상속 받는다.
따라서 "코드 재사용성"이 높아진다.
```

상속이 있고 없고 차이는 아래에서 알 수 있다.

![상속없이1](/image/20220727_17.jpg)
![상속없이2](/image/20220727_18.jpg)
![상속사용](/image/20220727_19.jpg)

이런 상속을 사용해서 만들면, 수정이 상당히 쉬어진다.
super() 로 바로 윗부모의 상속이 가능하다 \_\_init\_\_

다중 상속시, 모든것을 사용은 가능하다.
다만 중복되는 메서드에서는 상속 순서에 따라 결정된다.
결론적으로 말하면, `childrenclass(parants1,parants2)`
일때 parants1것을 사용한다. 먼저 받는걸 사용한다는뜻.
이 순서를 아는방법은 `.mro()` 메서드. 메서드를 참조하는 순서를 알려준다.

<br>

### 7.다형성

```
여러 모양을 의미한다. 동일한 메서드가, 클래스에 따라 다르게 행동한다는것.
서로 다른 클래스에 속해있는 객체들이, 동일한 메세지에대해 다르게 대응함.
간단하게 말하면, 상속받은 클래스가 메서드를 상속받는다고 해도 별도로 생성하여 사용할수 있다는것을 의미한다.
```

이를 위해서 상속받은 메서드를 `오버라이딩` 즉 재정의 해야한다.
말이 복잡해 보이는데, 상황이 3가지로 나눠서 보면된다
(1) 상속된 메서드를 그대로 쓰는경우 : 별도 코드없이 사용
(2) 상속된 메서드에 추가해서 쓰는경우 : super로 받고 추가해서 사용
(3) 오버라이딩 하는경우 : 기존 메서드 만드는 방식대로 만듬

<br>

### 8. 캡슐화

실존은 하지만, 언어적으로 존재하지 않는다는것.
이는 크게 public-> protected -> private 순서로 접근이 어려워지는데
public은 언더바 없이 시작하는 메서드나 속성으로, 어디서나 아무나 가능하다. override 허용
protected는 언더바 한개로 시작하는 메서드나 속성. 이는 `암묵적 규칙`에 의해 부모와 자식에서만 호출. override허용
private는 언더바 2개로 시작하는 메서드나 속성. 해당 클래스 내부에서만 사용이 가능하며, 상속 및 호출이 불가능하며 외부호출도 불가능.

![캡슐화 getter setter](/image/20220727_20.jpg)

하지만 실제 값을 조회하거나, 변경해야할때면 위와같이 getter, setter 방식을 사용한다.
두 방식은 함수를 사용한다기보단 하나의 틀(데코레이터)을 사용해서 만든다.
이러한 방법으로 다이렉트로 코딩에서 보이지 않게 캡슐화를 할 수 있고, 직접값이 변경 되는일을 막고
조회나 설정이 가능한것이다.
위 사진처럼 마치 코드에서 보면 직접 변수를 변경하고, 조회하는거같은데 실제 내부 코딩은 다르게 작동된다.

즉 캡슐화를 하는 이유는 크게 안정성을 위함일것이다.


추상화 : 복잡한것은 숨기고, 필요한것은 나타내는것 
상속 : 부모클래스-자식클래스간에 관계를 맺는것 (재사용성)
다형성 : 이름은 같지만, 다른 동작을 하는것 (오버라이딩)
캡슐화 : 민감한 정보를 숨기는것 (getter,setter,_, _ _)

![20220727 객체 간단정리](/image/20220727_21.jpg)

<br>

### 9. 에러

문법 에러가 자주 볼 수 있는데
- Invalid syntax : 문법오류
- assign to literal : 잘못된 할당(실수로 함수이름에 할당하거나, 말도않되는 할당일때)
- EOL : 끝맺음 실수함

### 10. 예외

문법은 맞는데, 예상치 못한 상황을 맞이하면 실행이 멈춘다.
이를 예외라고하며, 여러 type으로 나타난다.
웹페이지를 예시로 생각하면 로그인에러, 비밀번호 검증 에러 등등.. 많은것을 생각할 수 있다. 이것은 사용자정의 에러

- zerodivisionerror : 문자그대로 0으로 나눌때
- NameError : namespace 상에 없는걸 사용할때
- TypeError : 사용불가능한 타입이 사용될때
- ValueError : 타입(문법)은 맞지만, 값에대해 오류가 존재할때
- IndexError : 인덱스가 존재하지않거나, 범위를 벗어나는 경우
- KeyError : 키가 없는것을 찾으려할때 (보통 딕셔너리에서 발생하는데 `get()`을쓰면됨)
- ImportError : 모듈은 있으나, 존재하지 않는 클래스/함수를 기재할때

### 11. 예외처리

try문 / except절을 이용하여 예외처리.
try->except 으로 이어지는것.
기존에 if elif elif..하는거랑 비슷하다.
다만 좀더 에러가 나는 상황에 처리에 편리.

```
as 키워드 : A as B 는 B에 A를 대입한다는 의미.
```

![예외처리 예시1](/image/20220727_22.jpg)
![예외처리 예시2](/image/20220727_23.jpg)
<br>
ㄴ예외처리 예시


![예외처리 종합예시1](/image/20220727_24.jpg)
![예외처리 종합예시2](/image/20220727_25.jpg)
<br>
ㄴ예외처리 종합예시